package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

const FLAG_WXCONFIG = "wxconfig"
const FLAG_QUIET = "quiet"

var quiet bool
var wxConfig Path
var wxConfigFileName string = "wx-config"
var examplePath string = "/absolute/path/to/" + wxConfigFileName
var envPathSep = ":"

var requiredConfig = []string{"--static"}
var argVersion = []string{"--version-full"}
var argCppflags = append(requiredConfig, "--cppflags")
var argLdflags = append(requiredConfig, "--libs", "core", "base")
var argSelectedConfig = append(requiredConfig, "--selected-config")

const wxPackage = "github.com/kevin-yuan/wxgo/wx"
const setup = "setup.go"

func init() {
	if runtime.GOOS == "windows" {
		wxConfigFileName += ".exe"
		examplePath += `C:\path\to\` + wxConfigFileName
		envPathSep = ";"
	}
	flag.Var(&wxConfig, FLAG_WXCONFIG,
		fmt.Sprintf("The absolute path of \"%v\" executable. \"%v\" for example. Searching PATH environment if empty.", wxConfigFileName, examplePath))
	flag.BoolVar(&quiet, FLAG_QUIET, false, "Do not print the absolute path of setup.go after success.")
	flag.Parse()
}

func main() {
	// Get the path of wx-config.
	if wxConfig.Value == nil { // -wxconfig flag not set.
		if flag.NArg() > 1 { // Too many arguments.
			fmt.Fprintln(os.Stderr, "Invalid arguments!")
			fmt.Fprintln(os.Stderr, "Usage:")
			flag.PrintDefaults()
			os.Exit(1)
		}
		if flag.NArg() == 1 { // Only one argument, use it.
			wxConfig.Set(flag.Arg(0))
		} else { // Neither flag nor argrment, search PATH.
			var err error
			if *(wxConfig.Value), err = exec.LookPath(wxConfigFileName); err != nil {
				fmt.Fprintf(os.Stderr, "Can't find %v in PATH.\n", wxConfigFileName)
				fmt.Fprintln(os.Stderr, "Usage:")
				flag.PrintDefaults()
				os.Exit(1)
			}
		}
	}
	// Version.
	version := trimNewLine(runWxConfig(argVersion))
	// Selected config
	selectedConfig := trimNewLine(runWxConfig(argSelectedConfig))
	// Get flags.
	cppFlags := trimNewLine(runWxConfig(argCppflags))
	ldFlags := trimNewLine(runWxConfig(argLdflags))
	// Write file.
	wxgoDir := findWxGoPkgPath() // If failed, "" is the current directory.
	// use O_EXCL to avoid overwriting.
	setupPath, err := filepath.Abs(filepath.Join(wxgoDir, setup))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(4)
	}
	f, err := os.OpenFile(setupPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed! %v\n", err)
		os.Exit(3)
	}
	defer f.Close()
	fmt.Fprintf(f, `package wx
// Generated by wxgo/config. DO NOT EDIT!!

// %v: %v
// %v: %v

/*
#cgo CPPFLAGS: %v
#cgo LDFLAGS: %v
#cgo LDFLAGS: -lstdc++
*/
import "C"
`,
		strings.Join(argVersion, " "), version,
		strings.Join(argSelectedConfig, " "), selectedConfig,
		cppFlags, ldFlags)

	if !quiet {
		fmt.Println(setupPath)
	}

}

// findWxGoPkgPath try to find the directory of package "wxgo". Empty string
// is returned if not found.
func findWxGoPkgPath() string {
	gopaths := strings.Split(os.Getenv("GOPATH"), envPathSep)
	for _, gopath := range gopaths {
		path := filepath.Join(filepath.Join(gopath, "src"), wxPackage)
		if fi, err := os.Stat(path); err == nil && fi.IsDir() {
			return path
		}
	}
	return ""
}

func trimNewLine(str string) string {
	return strings.Trim(str, "\r\n")
}

// runWxConfig runs wx-config with specified args and returns the combined output
// if the process runs OK. os.Exit(2) if any error.
func runWxConfig(args []string) string {
	if out, err := exec.Command(*(wxConfig.Value), args...).CombinedOutput(); err != nil {
		fmt.Fprintln(os.Stderr, string(out))
		fmt.Fprintf(os.Stderr, "Failed to run %v %v: %v\n", *(wxConfig.Value), strings.Join(args, " "), err)
		os.Exit(2)
		return ""
	} else {
		return string(out)
	}
}

// A flag value that keeps the set state and string value.
type Path struct {
	Value *string
}

func (v *Path) String() string {
	if v.Value == nil {
		return `<search PATH>`
	}
	return *(v.Value)
}

func (v *Path) Set(val string) error {
	v.Value = &val
	return nil
}
